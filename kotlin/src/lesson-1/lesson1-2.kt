fun main(){
    //val x = 1231
    // long int - исползуется для бек
    // избегать преждевременной оптимизации
    // утечка памяти - один объект А и обект Б(держит ссылку на объект А) и С(держит Б)
    // если на объект никто не ссылается - его уничтожает - мусорщик
    // раньше живой объект - мертвый объект
    // циклическая зависимость
    //  раньше не могли найти такой цикл
    // теперь если из fun main можно дотянуться до таких объектов - то это мусор

    val b = B()
    val x = A(B())

    // если есть абстракция - есть наследование
    // сможете ли вы представить себе животное - нет,мы представим коня собаку, но животное - это общее понятие

    // обираем животных
    val list = listOf(B(),C())
    list.forEach{ animal : Animal ->
        animal.eat() // классич.пример полиморфизма
        // способность функции работать с разными типами
    }
}

abstract class AAA(){ // уже не сможем создать
    val b = B()
}

class A(){
    val b = B()
}
class AA(b: B){ // из вне
    val bx = b
}
class B(){

}
class C() : AAA()  // от абстракта
// class C() : B()

// в JS - это нижнее подчеркивание
// интерфейс - то же что и абстракт,помечаем,контракт между объект
// этот объект обязан наследовать - обязан реализовать

interface I{
    fun ii()
}

// двоеточие - синтаксис наследование,реализация
class CC() : I{ // загорелся красным
    override fun ii() {
        TODO("Not yet implemented")
    }

}

class V : B(),I{
    override fun ii() {
        TODO("Not yet implemented")
    }
}
// в котлине все классы закрыты - поэтому указываем OPEN
// в JAVA все классы открыты
// полиморфизм - у тебя есть жтвотные и ты им говоришь кущать - они все кушают но каждый по-своему

interface Animal{
    fun eat(){
        //// addds
    }
}

class L : Animal{
    override fun eat() {

    }
}